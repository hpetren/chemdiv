#' Plot chemodiversity
#'
#' Function to conveniently create basic plots of the different types of
#' chemodiversity measurements created by various functions in the package.
#'
#' The function can create four different types of plots (using ggplot2)
#' depending on which input data is supplied.
#' \itemize{
#' \item A compound dissimilarity matrix, \code{compDisMat}, will be
#' plotted as a dendrogram visualizing which compounds are
#' structurally/biosynthethically similar to each other.
#' \item Diversity/evenness, \code{divData}, is plotted as a boxplot.
#' \item A diversity profile, plotting (Functional) Hill diversity at different
#' values of q will be plotted with \code{divProfData} (NB! This is
#' the whole list outputted by calcDivProf, as qMin and qMax are used too).
#' \item A sample dissimilarity matrix, \code{sampleDisMat}, will be plotted
#' as an NMDS plot.
#' \item Grouping data, \code{groupData}, may be supplied.
#' }
#' Note that this function can take any combination of the four arguments
#' as input, and argument names should always be specified to ensure
#' each dataset is correctly plotted.
#'
#'
#' @param compDisMat Compound dissimilarity matrix,
#' generated by the \code{compDis} function.
#' @param divData Diversity/evenness data frame,
#' generated by the \code{calcDiv} function. This dataframe can contain
#' a single or multiple columns with diversity/evenness measures.
#' @param divProfData Diversity profile data frame,
#' generated by the \code{calcDivProf} function.
#' @param sampleDisMat Sample dissimilarity matrix, generated by
#' the \code{sampleDis} function. This can be either the list of one or
#' both matrices outputted by the function, or a single matrix directly.
#'
#' @param groupData Grouping data.
#'
#' @return Various plots on chemodiversity.
#'
#' @export
#'
#' @examples
#' data(minimalCompDis)
#' data(minimalSampDis)
#' minimalDiv <- calcDiv(minimalSampData, minimalCompDis, type = "FuncHillDiv")
#' minimalDivProf <- calcDivProf(minimalSampData, minimalCompDis, type = "FuncHillDiv")
#' groups <- c("A", "A", "B", "B")
#' chemDivPlot(compDisMat = minimalCompDis, divData = minimalDiv,
#' divProfData = minimalDivProf, sampleDisMat = minimalSampDis,
#' groupData = groups)
chemDivPlot <- function(compDisMat = NULL,
                        divData = NULL,
                        divProfData = NULL,
                        sampleDisMat = NULL,
                        groupData = NULL) {

  allPlots <- list()

  if (!is.null(compDisMat)) { # Compound tree

    compDisMatClust <- stats::hclust(stats::as.dist(compDisMat),
                                     method = "average")
    compDisMatClustDend <- stats::as.dendrogram(compDisMatClust)
    compDisMatClustDendData <- ggdendro::dendro_data(compDisMatClustDend)

    # Now using ggplot2:: for everything, and aes(.data$) as recommended
    compDisMatTreePlot <- ggplot2::ggplot() +
      ggplot2::geom_segment(data = compDisMatClustDendData$segments,
                            ggplot2::aes(x = .data$x,
                                         y = .data$y,
                                         xend = .data$xend,
                                         yend = .data$yend)) +
      ggplot2::geom_text(data = compDisMatClustDendData$labels,
                         ggplot2::aes(x = .data$x,
                                      y = .data$y,
                                      label = .data$label),
                         hjust = -0.1, angle = 0) +
      ggplot2::scale_y_reverse(limits = c(1, -0.5),
                               breaks = c(1, 0.75, 0.5, 0.25, 0)) +
      ggplot2::ylab("Dissimilarity") +
      ggplot2::ggtitle("") +
      ggplot2::theme(axis.title.y = ggplot2::element_blank(),
                     axis.text.y = ggplot2::element_blank(),
                     axis.ticks.y = ggplot2::element_blank(),
                     panel.grid.major = ggplot2::element_blank(),
                     panel.grid.minor = ggplot2::element_blank(),
                     panel.border = ggplot2::element_blank(),
                     panel.background = ggplot2::element_blank(),
                     axis.line.x = ggplot2::element_line(color = "black",
                                                         size = 0.5)) +
      ggplot2::coord_flip()

    allPlots[["compDisMatTreePlot"]] <- compDisMatTreePlot
  }

  if (!is.null(divData)) { # Boxplot of diversity/evenness

    divDatadf <- as.data.frame(divData) # Make sure it's a df,
    # as that is not the case if only one column is input

    if (is.null(groupData)) {
      message("No grouping data provided.")
      groupData <- rep("NoGroup", nrow(divDatadf))
    }
    divDatadf$Group <- groupData

    # Plot(s). Note that if a single column from df with multiple columns
    # is indata, then y-axis is not specified. I don't think this can be solved
    # as then it's only a vector, but it's not a big problem, so keeping it
    # like this
    for (i in 1:(ncol(divDatadf)-1)) {
      allPlots[[paste0("divPlot", colnames(divDatadf)[i])]] <- local({
        i <- i
        currentCol <- colnames(divDatadf)[i]

        divPlot <- ggplot2::ggplot(data = divDatadf,
                                   ggplot2::aes(x = .data$Group,
                                                y = .data[[currentCol]],
                                                fill = .data$Group)) +
          ggplot2::geom_boxplot(outlier.shape = NA) +
          ggplot2::geom_jitter(height = 0, width = 0.1, shape = 21) +
          ggplot2::ylab(currentCol) +
          ggplot2::theme(text = ggplot2::element_text(size = 15),
                         legend.position = "none")
      })
    }
  }

  if (!is.null(divProfData)) { # Diversity profile

    if (is.null(groupData)) {
      message("No grouping data provided.")
      groupData <- rep("NoGroup", nrow(divProfData$divProf))
    }
    divProf <- divProfData$divProf # Extract the df from the list

    # Get mean data in order
    divProfMean1 <- stats::aggregate(divProf,
                                     by = list(Group = groupData), mean)
    divProfMean2 <- as.data.frame(t(divProfMean1[, 2:ncol(divProfMean1)]))
    colnames(divProfMean2) <- divProfMean1$Group
    qAll <- seq(from = divProfData$qMin,
                to = divProfData$qMax,
                by = divProfData$step)
    divProfMean2$q <- qAll
    divHillLong <- tidyr::pivot_longer(divProfMean2,
                                       1:(ncol(divProfMean2) - 1),
                                       names_to = "Group",
                                       values_to = "Diversity")

    # Get individual sample data in order
    divProfInd <- as.data.frame(t(divProf))
    divProfInd$q <- qAll
    divHillLongInd <- tidyr::pivot_longer(divProfInd,
                                          1:(ncol(divProfInd) - 1),
                                          names_to = "Individual",
                                          values_to = "Diversity")
    divHillLongInd$Group <- rep(groupData, length(unique(divProfInd$q)))

    divProfPlot <- ggplot2::ggplot() +
      ggplot2::geom_line(data = divHillLongInd, # Note use of group and color
                         ggplot2::aes(x = .data$q,
                                      y = .data$Diversity,
                                      group = .data$Individual,
                                      color = .data$Group),
                         size = 0.5, alpha = 0.15) +
      ggplot2::geom_line(data = divHillLong,
                         ggplot2::aes(x = .data$q,
                                      y = .data$Diversity,
                                      color = .data$Group),
                         size = 1.5) +
      ggplot2::xlab("Diversity order (q)") +
      ggplot2::ylab(divProfData$type) +
      ggplot2::theme(text = ggplot2::element_text(size = 15))

    allPlots[["divProfPlot"]] <- divProfPlot
  }

  if (!is.null(sampleDisMat)) { # NMDS

    if (is.null(groupData)) {
      message("No grouping data provided.")
      groupData <- rep("NoGroup", nrow(sampleDisMat))
    }

    # If input is a single matrix
    if (is.matrix(sampleDisMat)) {

      # Suppressing iteration output here requires capture.output() rather
      # than suppressMessage() as metaMDSiter() prints output with cat()
      # rather than with message() (which is more correct)
      # https://stackoverflow.com/questions/8797314/suppress-messages-displayed-by-print-instead-of-message-or-warning-in-r
      utils::capture.output(NMDS <- vegan::metaMDS(sampleDisMat,
                                                   autotransform = FALSE))
      NMDSCoords <- as.data.frame(NMDS$points)
      NMDSCoords$Group <- groupData
      NMDSPlot <- ggplot2::ggplot(data = NMDSCoords,
                                  ggplot2::aes(x = .data$MDS1,
                                               y = .data$MDS2,
                                               color = .data$Group)) +
        ggplot2::geom_point(size = 4, alpha = 0.5) +
        ggplot2::theme(text = ggplot2::element_text(size = 15))
      allPlots[["NMDSPlot"]] <- NMDSPlot

    } else { # If input is a list with a BrayCurtis and a GenUniFrac matrix

      utils::capture.output(BCNMDS <- vegan::metaMDS(sampleDisMat$BrayCurtis,
                                                     autotransform = FALSE))
      BCNMDSCoords <- as.data.frame(BCNMDS$points)
      BCNMDSCoords$Group <- groupData
      BCNMDSPlot <- ggplot2::ggplot(data = BCNMDSCoords,
                                    ggplot2::aes(x = .data$MDS1,
                                                 y = .data$MDS2,
                                                 color = .data$Group)) +
        ggplot2::geom_point(size = 4, alpha = 0.5) +
        ggplot2::theme(text = ggplot2::element_text(size = 15)) +
        ggplot2::ggtitle("Bray-Curtis NMDS")
      allPlots[["BCNMDSPlot"]] <- BCNMDSPlot


      utils::capture.output(GUNMDS <- vegan::metaMDS(sampleDisMat$GenUniFrac,
                                                     autotransform = FALSE))
      GUNMDSCoords <- as.data.frame(GUNMDS$points)
      GUNMDSCoords$Group <- groupData
      GUNMDSPlot <- ggplot2::ggplot(data = GUNMDSCoords,
                                    ggplot2::aes(x = .data$MDS1,
                                                 y = .data$MDS2,
                                                 color = .data$Group)) +
        ggplot2::geom_point(size = 4, alpha = 0.5) +
        ggplot2::theme(text = ggplot2::element_text(size = 15)) +
        ggplot2::ggtitle("Generalized UniFrac NMDS")
      allPlots[["GUNMDSPlot"]] <- GUNMDSPlot
    }
  }
  # Arranging plots
  gridExtra::grid.arrange(grobs = allPlots,
                          ncol = ceiling(sqrt(length(allPlots))))
}
