#' Calculate compound dissimilarities
#'
#' Function to calculate dissimilarities between compounds
#'
#' This function calculates compound dissimilarities in three different ways:
#' 1. Using the classification from NPClassifier, which largely correspond
#' to biosynthetic groups/pathways.
#' 2. Using PubChem Fingerprints, a
#' a binary substructure fingerprint with 881 binary variables describing
#' the chemical structure of a compound.
#' 3. fMCS, flexible Maximum Common
#' Substructure, a pairwise graph matching concept allowing for atom and/or
#' bond mismatches. Dissimilarities using NPClassifier and PubChem Fingerprints
#' are generated by calculating Jaccard dissimilarities from a 0/1 table with
#' compounds as rows and group (NPClassifier) or binary fingerprint variable
#' (PubChem Fingerprints) as columns. fMCS generates dissimilarity
#' values directly (allowing for one atom and one bond mismatch).
#'
#'
#' @param compoundData Data frame with the chemical compounds of interest.
#' Should have a column named "compound" with common names, and a column named
#' "smiles" with SMILES IDs for the compounds.
#' @param type Type of dissimilarity to calculate, NPClassifier,
#' PubChemFingerprint or fMCS. If more than one is choosen, a mean of
#' the included types will also be calculated
#' @param npcTable An already generated NPCTable can optionally be supplied
#' @param unknownCompoundsMean If unknown compound should be given
#' mean dissimilarity values. If not, these will have dissimilarity 1 to
#' all other compounds
#'
#' @return List with compound dissimilarity matrices
#'
#' @export
#'
#' @examples
#' data(minimalCompData)
#' compDis(minimalCompData)
compDis <- function(compoundData,
                    type = c("NPClassifier", "PubChemFingerprint", "fMCS"),
                    npcTable = NULL,
                    unknownCompoundsMean = FALSE) {

  if(!(any(c("NPClassifier", "PubChemFingerprint", "fMCS") %in% type))) {
    stop("Provide at least one type of compound dissimilarity to calculate:
         NPClassifier, PubChemFingerprint or fMCS")
  }


  compoundDisMatList <- list()

  if ("NPClassifier" %in% type) { # Dissimilarities from NPClassifier

    print("Calculating compound dissimilarity matrix using NPClassifier...")

    if(any(is.na(compoundData$smiles))){
      warning("There are compounds with missing smiles")
    }

    if (is.null(npcTable)) { # If we don't already have the table
      # Copied from npcTable()

      npcTable <- compoundData


      npcTable$pathway <- NA
      npcTable$pathway2 <- NA
      npcTable$pathway3 <- NA
      npcTable$superclass <- NA
      npcTable$superclass2 <- NA
      npcTable$superclass3 <- NA
      npcTable$class <- NA
      npcTable$class2 <- NA
      npcTable$class3 <- NA


      for (i in 1:nrow(npcTable)) {

        # Avoiding NA
        if(!is.na(npcTable$smiles[i])) {

          # Get the NPC for the SMILES and get into correct format
          npcclass_prel <- httr::GET("https://npclassifier.ucsd.edu/classify",
                               query = list(smiles = npcTable$smiles[i]))


          # This is just one long character string
          npcclass_real <- httr::content(npcclass_prel, as = "text")


          if(substring(npcclass_real, 1, 1) == "{") {

            #print(paste0("Classifying compound: ", i))

            npcclass_real_correct <- jsonlite::fromJSON(npcclass_real)


            if (is.character(npcclass_real_correct$pathway_results)) {

              npcTable$pathway[i] <- npcclass_real_correct$pathway_results[1]
              npcTable$pathway2[i] <- npcclass_real_correct$pathway_results[2]
              npcTable$pathway3[i] <- npcclass_real_correct$pathway_results[3]

            } else { print(paste0("NPClassifier has no classification for compound ", i)) }


            if (is.character(npcclass_real_correct$superclass_results)) {

              npcTable$superclass[i] <- npcclass_real_correct$superclass_results[1]
              npcTable$superclass2[i] <- npcclass_real_correct$superclass_results[2]
              npcTable$superclass3[i] <- npcclass_real_correct$superclass_results[3]

            }

            if (is.character(npcclass_real_correct$class_results)) {

              npcTable$class[i] <- npcclass_real_correct$class_results[1]
              npcTable$class2[i] <- npcclass_real_correct$class_results[2]
              npcTable$class3[i] <- npcclass_real_correct$class_results[3]

            }

            # If something went wrong
          } else { print(paste0("Compound ", i, " could not be classified
                                at all. Is the SMILES correct?")) }
        }
      }
    }


    # From long to wide ###
    # Initiating a data frame
    npcTableWide <- data.frame(compound = npcTable$compound)


    for (i in 1:nrow(npcTable)) { # For each compound
      for (j in which(colnames(npcTable) == "pathway"):ncol(npcTable)) {
        # For each classification (from pathway and onwards)

        if (npcTable[i,j] %in% colnames(npcTableWide)) {
          # If the name already exist as column in npcTableWide

          # Get column number
          colNumber <- match(npcTable[i,j], colnames(npcTableWide))

          # Add a 1 in the correct column
          npcTableWide[i, colNumber] <- 1

        } else if (!is.na(npcTable[i,j])) {
          # If the name do not already exist as column in npcTableWide
          # (if i,j is NA nothing is done)

          # Make a new column, which has the name from npcTable[i,j]
          npcTableWide[,npcTable[i,j]] <- NA

          # Add a 1 at the correct row in the current column
          npcTableWide[i,npcTable[i,j]] <- 1

        }
      }
    }


    # Fixing Greek letters in class names. Included all, even
    # though it's probably not needed
    # THIS MUST BE POSSIBLE TO BE MADE MORE SIMPLE???

    # Lower case
    correctColNames <- gsub("\u03b1", "alpha", colnames(npcTableWide))
    correctColNames <- gsub("\u03b2", "beta", correctColNames)
    correctColNames <- gsub("\u03b3", "gamma", correctColNames)
    correctColNames <- gsub("\u03b4", "delta", correctColNames)
    correctColNames <- gsub("\u03b5", "epsilon", correctColNames)
    correctColNames <- gsub("\u03b6", "zeta", correctColNames)
    correctColNames <- gsub("\u03b7", "eta", correctColNames)
    correctColNames <- gsub("\u03b8", "theta", correctColNames)
    correctColNames <- gsub("\u03b9", "iota", correctColNames)
    correctColNames <- gsub("\u03ba", "kappa", correctColNames)
    correctColNames <- gsub("\u03bb", "lambda", correctColNames)
    correctColNames <- gsub("\u03bc", "mu", correctColNames)
    correctColNames <- gsub("\u03bd", "nu", correctColNames)
    correctColNames <- gsub("\u03be", "xi", correctColNames)
    correctColNames <- gsub("\u03bf", "omicron", correctColNames)
    correctColNames <- gsub("\u03c0", "pi", correctColNames)
    correctColNames <- gsub("\u03c1", "rho", correctColNames)
    correctColNames <- gsub("\u03c3", "sigma", correctColNames)
    correctColNames <- gsub("\u03c4", "tau", correctColNames)
    correctColNames <- gsub("\u03c5", "upsilon", correctColNames)
    correctColNames <- gsub("\u03c6", "phi", correctColNames)
    correctColNames <- gsub("\u03c7", "chi", correctColNames)
    correctColNames <- gsub("\u03c8", "psi", correctColNames)
    correctColNames <- gsub("\u03c9", "omega", correctColNames)

    # Upper case
    correctColNames <- gsub("\u0391", "Alpha", colnames(npcTableWide))
    correctColNames <- gsub("\u0392", "Beta", correctColNames)
    correctColNames <- gsub("\u0393", "Gamma", correctColNames)
    correctColNames <- gsub("\u0394", "Delta", correctColNames)
    correctColNames <- gsub("\u0395", "Epsilon", correctColNames)
    correctColNames <- gsub("\u0396", "Zeta", correctColNames)
    correctColNames <- gsub("\u0397", "Eta", correctColNames)
    correctColNames <- gsub("\u0398", "Theta", correctColNames)
    correctColNames <- gsub("\u0399", "Iota", correctColNames)
    correctColNames <- gsub("\u039a", "Kappa", correctColNames)
    correctColNames <- gsub("\u039b", "Lambda", correctColNames)
    correctColNames <- gsub("\u039c", "Mu", correctColNames)
    correctColNames <- gsub("\u039d", "Nu", correctColNames)
    correctColNames <- gsub("\u039e", "Xi", correctColNames)
    correctColNames <- gsub("\u039f", "Omicron", correctColNames)
    correctColNames <- gsub("\u03a0", "Pi", correctColNames)
    correctColNames <- gsub("\u03a1", "Rho", correctColNames)
    correctColNames <- gsub("\u03a3", "Sigma", correctColNames)
    correctColNames <- gsub("\u03a4", "Tau", correctColNames)
    correctColNames <- gsub("\u03a5", "Upsilon", correctColNames)
    correctColNames <- gsub("\u03a6", "Phi", correctColNames)
    correctColNames <- gsub("\u03a7", "Chi", correctColNames)
    correctColNames <- gsub("\u03a8", "Psi", correctColNames)
    correctColNames <- gsub("\u03a9", "Omega", correctColNames)

    colnames(npcTableWide) <- correctColNames


    # Replacing NA with 0
    npcTableWide[is.na(npcTableWide)] <- 0

    # Making distance matrix out of it
    npcDis <- as.matrix(vegan::vegdist(npcTableWide[,2:ncol(npcTableWide)],
                                       method = "jaccard"))

    colnames(npcDis) <- npcTableWide$compound
    rownames(npcDis) <- npcTableWide$compound

    # If there are >1 NA (unknown compound) these become NaN to each
    # other in vegdist. Setting these manually to 1.
    npcDis[is.nan(npcDis)] <- 1

    # Print warning if there are NA's in pathway (either because compound
    # was unknow, or not classified by NPC)
    pathwayNA <- any(is.na(npcTable$pathway))
    if(pathwayNA){
      warning("There were compounds not classfied by NPClassifier")
    }


    # If one decides to set unknown compounds to mean values
    if (unknownCompoundsMean & pathwayNA) {

      # Subsetting only known compounds
      npcKnown <- npcDis[-which(is.na(npcTable$pathway)),
                         -which(is.na(npcTable$pathway))]

      # mean compound dissimilarity
      meanDis <- mean(npcKnown[lower.tri(npcKnown)])

      # We replace those rows and columns (can't do both at once) with mean values
      npcDis[which(is.na(npcTable$pathway)),] <- meanDis
      npcDis[,which(is.na(npcTable$pathway))] <- meanDis

      # And the make sure diagonal is all 0 again
      diag(npcDis) <- 0

    }

    compoundDisMatList[["npcDisMat"]] <- npcDis

  }

  if ("PubChemFingerprint" %in% type) { # Dissimilarities from Fingerprints

    print("Calculating compound dissimilarity matrix using Fingerprints...")

    if(any(is.na(compoundData$inchikey))){
      warning("Fingerprint calculations: There are compounds with missing inchikey")
    }

    # Getting CID from inchikey (It was here that smiles didn't work).
    # Match is first, because it seems PubChem has some duplicates,
    # or strange variants, e.g. WPYMKLBDIGXBTP-UHFFFAOYSA-N
    compoundCID <- webchem::get_cid(query = compoundData$inchikey,
                           from = "inchikey",
                           match = "first")

    # If there are NA cid (due to NA inchikey)
    # getIds can't handle NAs
    if(any(is.na(compoundCID$cid))) { # if at least 1 NA

      # Get cid
      cid <- compoundCID$cid

      # Get all not NA cid and get their fingerprints
      cidNoNA <- compoundCID$cid[!is.na(compoundCID$cid)]

      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(cidNoNA))

      compoundbit <- ChemmineR::fp2bit(compoundSDF)
      compoundFinger <- as.data.frame(compoundbit@fpma)

      colnames(compoundFinger) <- c(paste0("bit", seq(1:881)))

      # Make a similar dataframe with only 0, with same number
      # of columns and number of rows equal to number of NA compounds.
      # We put 0 and not NA into this, because we use this to calculate
      # dissimilarities. Rows with all 0 values while have a jaccard
      # distance of 1 to all others (as I currently want). In contrast,
      # vegdist() throws error if there are NAs in community matrix
      # (and we don't want that). This is all correct and the same as in
      # npcDis.
      # THIS SHOULDN'T BE CALLED NA MATRIX I GUESS
      cidNAMatrix <- matrix(data = 0, nrow = sum(is.na(cid)),
                            ncol = ncol(compoundFinger))

      colnames(cidNAMatrix) <- c(paste0("bit", seq(1:881)))

      # Get index of NA cid
      rowWithNA <- which(is.na(cid))

      # This puts each NA row into it's correct place using rbind(),
      # by taking first part of compoundFinger, inserting NA row into
      # correct place, and then taking second part of compoundFinger.
      # rbind() is apperently slow, but should work here.
      # https://stackoverflow.com/questions/11561856/add-new-row-to-dataframe-at-specific-row-index-not-appended
      for (i in 1:length(rowWithNA)) {

        if(rowWithNA[i] == 1) { # If first compound is NA

          compoundFinger <- rbind(cidNAMatrix[i,], compoundFinger)

        } else if (rowWithNA[i] > nrow(compoundFinger)) {
          # If (any number of) last compound(s) are NA
          compoundFinger <- rbind(compoundFinger, cidNAMatrix[i,])

        } else {
          compoundFinger <- rbind(compoundFinger[1:(rowWithNA[i]-1),],
                                  cidNAMatrix[i,],
                                  compoundFinger[rowWithNA[i]:nrow(compoundFinger),])
        }
      }

    } else { # If no NA
      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid))

      # Extracting fingerprints
      compoundbit <- ChemmineR::fp2bit(compoundSDF)
      compoundFinger <- as.data.frame(compoundbit@fpma)

      # Changing names of bits to not have strange column names
      colnames(compoundFinger) <- c(paste0("bit", seq(1:881)))
    }


    # Calculate dissimilarity matrix based on fingerprints
    fingerDis <- vegan::vegdist(compoundFinger, method = "jaccard")
    fingerDisMat <- as.matrix(fingerDis)

    # Using the compound names for plotting the tree
    colnames(fingerDisMat) <- compoundData$compound
    rownames(fingerDisMat) <- compoundData$compound

    # If there are >1 NA (unknown compound) these become NaN to each
    # other in vegdist. Setting these manually to 1.
    fingerDisMat[is.nan(fingerDisMat)] <- 1


    # If there are unknown compound and one decides to set
    # unknown compounds to mean values

    if (unknownCompoundsMean & any(is.na(compoundCID$cid))) {

      # Subsetting only known compounds
      fingerKnown <- fingerDisMat[-rowWithNA, -rowWithNA]

      # mean compound dissimilarity
      meanDis <- mean(fingerKnown[lower.tri(fingerKnown)])

      # We replace those rows and columns (can't do both at once) with mean values
      fingerDisMat[rowWithNA,] <- meanDis
      fingerDisMat[,rowWithNA] <- meanDis

      # And the make sure diagonal is all 0 again
      diag(fingerDisMat) <- 0

    }

    compoundDisMatList[["fingerDisMat"]] <- fingerDisMat

  }

  if ("fMCS" %in% type) { # Dissimilarities from fMCS

    print("Calculating compound dissimilarity matrix using fMCS...")

    if(any(is.na(compoundData$inchikey))){
      warning("fMCS calculations: There are compounds with missing inchikey")
    }

    if(!exists("compoundCID")) {
      compoundCID <- webchem::get_cid(query = compoundData$inchikey,
                                      from = "inchikey",
                                      match = "first")
    }


    if (any(is.na(compoundCID$cid))) {

      # This must be done without NA
      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid[!is.na(compoundCID$cid)]))

      rowWithNA <- which(is.na(compoundCID$cid))

      # Doing with 1 atom and 1 bond mismatch for now. I think there is a motivation
      # for this in some earlier R-script. Note that this is similarity matrix
      # as it's Tanimoto coefficient (Jaccard similarity)
      fmcsSimMat <- sapply(ChemmineR::cid(compoundSDF),
                           function(x) fmcsR::fmcsBatch(compoundSDF[x],
                                                 compoundSDF,
                                                 au=1,
                                                 bu=1)[,"Tanimoto_Coefficient"])


      meanSim <- mean(fmcsSimMat[lower.tri(fmcsSimMat)])


      if (unknownCompoundsMean) { # Adding mean similarity

        for (i in 1:length(rowWithNA)) {

          if(rowWithNA[i] == 1) { # If first compound is NA
            fmcsSimMat <- rbind(rep(meanSim,ncol(fmcsSimMat)), fmcsSimMat)
            fmcsSimMat <- cbind(rep(meanSim,nrow(fmcsSimMat)), fmcsSimMat)

          } else if (rowWithNA[i] > nrow(fmcsSimMat)) { # If last compound(s) are NA
            fmcsSimMat <- rbind(fmcsSimMat, rep(meanSim,ncol(fmcsSimMat)))
            fmcsSimMat <- cbind(fmcsSimMat, rep(meanSim,nrow(fmcsSimMat)))

          } else {
            fmcsSimMat <- rbind(fmcsSimMat[1:(rowWithNA[i]-1),],
                                rep(meanSim,ncol(fmcsSimMat)),
                                fmcsSimMat[rowWithNA[i]:nrow(fmcsSimMat),])
            fmcsSimMat <- cbind(fmcsSimMat[,1:(rowWithNA[i]-1)],
                                rep(meanSim,nrow(fmcsSimMat)),
                                fmcsSimMat[,rowWithNA[i]:ncol(fmcsSimMat)])
          }
        }

      } else { # Adding 0 similarity

        # Putting rows/column with unknown compounds into correct place
        # Code edited from function above
        for (i in 1:length(rowWithNA)) {

          if(rowWithNA[i] == 1) { # If first compound is NA
            fmcsSimMat <- rbind(rep(0,ncol(fmcsSimMat)), fmcsSimMat)
            fmcsSimMat <- cbind(rep(0,nrow(fmcsSimMat)), fmcsSimMat)

          } else if (rowWithNA[i] > nrow(fmcsSimMat)) { # If last compound(s) are NA
            fmcsSimMat <- rbind(fmcsSimMat, rep(0,ncol(fmcsSimMat)))
            fmcsSimMat <- cbind(fmcsSimMat, rep(0,nrow(fmcsSimMat)))

          } else {
            fmcsSimMat <- rbind(fmcsSimMat[1:(rowWithNA[i]-1),],
                                rep(0,ncol(fmcsSimMat)),
                                fmcsSimMat[rowWithNA[i]:nrow(fmcsSimMat),])
            fmcsSimMat <- cbind(fmcsSimMat[,1:(rowWithNA[i]-1)],
                                rep(0,nrow(fmcsSimMat)),
                                fmcsSimMat[,rowWithNA[i]:ncol(fmcsSimMat)])
          }
        }
      }


      diag(fmcsSimMat) <- 1


    } else {

      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid))

      fmcsSimMat <- sapply(ChemmineR::cid(compoundSDF),
                           function(x) fmcsR::fmcsBatch(compoundSDF[x],
                                                 compoundSDF,
                                                 au=1,
                                                 bu=1)[,"Tanimoto_Coefficient"])

    }

    fmcsDisMat <- 1 - fmcsSimMat

    colnames(fmcsDisMat) <- compoundData$compound
    rownames(fmcsDisMat) <- compoundData$compound

    compoundDisMatList[["fmcsDisMat"]] <- fmcsDisMat

  }

  if (length(type) > 1) { # If > 1 dissimilarity matrix is requested

    # Weird way of calculating mean for each element.
    # Then adding that to list

    compoundDisMatList[["meanDisMat"]] <- Reduce("+", compoundDisMatList) /
      length(compoundDisMatList)

  }
  print("Done")
  return(compoundDisMatList)
}


