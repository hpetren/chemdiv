#' Calculate compound dissimilarities
#'
#' Function to calculate dissimilarities between compounds.
#'
#' This function calculates compound dissimilarities in three different ways:
#' 1. Using the classification from NPClassifier, which largely correspond
#' to biosynthetic groups/pathways.
#' 2. Using PubChem Fingerprints, a binary substructure fingerprint with
#' 881 binary variables describing the chemical structure of a compound.
#' 3. fMCS, flexible Maximum Common Substructure,
#' a pairwise graph matching concept allowing for atom and/or
#' bond mismatches. Dissimilarities using NPClassifier and PubChem Fingerprints
#' are generated by calculating Jaccard dissimilarities from a 0/1 table with
#' compounds as rows and group (NPClassifier) or binary fingerprint variable
#' (PubChem Fingerprints) as columns. fMCS generates dissimilarity
#' values directly (allowing for one atom and one bond mismatch).
#'
#'
#' @param compoundData Data frame with the chemical compounds of interest.
#' Should have a column named "compound" with common names, and a column named
#' "smiles" with SMILES IDs for the compounds.
#' @param type Type of dissimilarity to calculate, NPClassifier,
#' PubChemFingerprint or fMCS. If more than one is choosen, a mean of
#' the included types will also be calculated.
#' @param npcTable An already generated \code{\link{NPCTable}}
#' can optionally be supplied. If compound distances are to be calculated using
#' the NPC-classification and NPClassifier is unable to fully classify
#' all compounds, it might be beneficial to run \code{\link{NPCTable}},
#' manually edit the resulting data frame with probable classifications if
#' possible (from the SI in Kim et al. 2021), and then supply this
#' classification to \code{compDis()} with the npcTable argument. This will ensure
#' that compound dissimilarities are computed optimally.
#'
#' @param unknownCompoundsMean If unknown compounds, i.e. ones without SMILES,
#' should be given mean dissimilarity values. If not, these will have
#' dissimilarity 1 to all other compounds.
#'
#' @return List with compound dissimilarity matrices. A list is always
#' outputted, even if only one matrix is calculated. Downstream functions,
#' including \code{\link{calcDiv}}, \code{\link{calcBetaDiv}},
#' \code{\link{calcDivProp}}, \code{\link{sampleDis}},
#' \code{\link{molNet}} and \code{\link{chemDivPlot}} require only the matrix
#' as input (subsetted with e.g. fullList$specificMatrix) and not the whole list
#'
#'
#' @export
#'
#' @references
#' Kim, H. W., M. Wang, C. A. Leber, L.-F. Nothias, R. Reher, K. B. Kang,
#' J. J. J. van der Hooft, P. C. Dorrestein, W. H. Gerwick,
#' and G. W. Cottrell. 2021. NPClassifier: A Deep Neural Network-Based
#' Structural Classification Tool for Natural Products.
#' Journal of Natural Products:acs.jnatprod.1c00399.
#' UPDATE WITH FULL REF WHEN AVAILABLE
#'
#' @examples
#' data(minimalCompData)
#' compDis(minimalCompData)
compDis <- function(compoundData,
                    type = c("NPClassifier", "PubChemFingerprint", "fMCS"),
                    npcTable = NULL,
                    unknownCompoundsMean = FALSE) {

  if(!(any(c("NPClassifier", "PubChemFingerprint", "fMCS") %in% type))) {
    stop("Provide at least one type of compound dissimilarity to calculate:
         NPClassifier, PubChemFingerprint or fMCS")
  }

  colnames(compoundData) <- tolower(colnames(compoundData))

  compoundDisMatList <- list()

  if ("NPClassifier" %in% type) { # Dissimilarities from NPClassifier

    message("Calculating compound dissimilarity matrix using NPClassifier...")

    if (is.null(npcTable)) { # If we don't already have the table

      npcTable <- compoundData

      npcTable[c("pathway", "pathway2", "pathway3",
               "superclass", "superclass2", "superclass3",
               "class", "class2", "class3")] <- NA

      for (i in 1:nrow(npcTable)) {

        # No NA
        if (!is.na(npcTable$smiles[i])) {

          # Get the NPC for the SMILES
          # NOTE! This gives an error, but still works...
          npcClass1 <- httr::GET("https://npclassifier.ucsd.edu/classify",
                                 query = list(smiles = npcTable$smiles[i]))

          # Retrieving contents
          npcClass2 <- httr::content(npcClass1, as = "text")

          # If the request for some reason fails then npcClass2
          # is not in proper format, and does not begin with "{",
          # so we check for that (we have to do that, because otherwise
          # fromJSON() throws an error and loop stops)
          if (substring(npcClass2, 1, 1) == "{") {

            # Parsing the long json character string, into a list
            npcClass3 <- jsonlite::fromJSON(npcClass2)

            # Check if there is any classifications (otherwise empty list), then
            # put in correct place in df
            if (is.character(npcClass3$pathway_results)) {

              # Adding pathway. In cases there is only 1 pathway, trying to
              # take an index that is higher then what is in the vector
              # just returns NA, which is appropriate
              npcTable$pathway[i] <- npcClass3$pathway_results[1]
              npcTable$pathway2[i] <- npcClass3$pathway_results[2]
              npcTable$pathway3[i] <- npcClass3$pathway_results[3]

              # If the compound is not classified, but there is nothing wrong
              # (i.e. the pathway is NA)
            } else {
              message(paste("NPClassifier has no classification for compound", i))
            }

            if (is.character(npcClass3$superclass_results)) {
              npcTable$superclass[i] <- npcClass3$superclass_results[1]
              npcTable$superclass2[i] <- npcClass3$superclass_results[2]
              npcTable$superclass3[i] <- npcClass3$superclass_results[3]
            }

            if (is.character(npcClass3$class_results)) {
              npcTable$class[i] <- npcClass3$class_results[1]
              npcTable$class2[i] <- npcClass3$class_results[2]
              npcTable$class3[i] <- npcClass3$class_results[3]
            }
            # If the output from NPClassifier API is not as expected
          } else {
            message(paste("NPClassifier produced error output for Compound", i,
                          "Is the SMILES correct?"))
          }
        }
      }
    }

    # If there are NAs, then inform about this
    if (any(is.na(npcTable$pathway)) ||
        any(is.na(npcTable$superclass)) ||
        any(is.na(npcTable$class))) {
      message("NPClassifier calculations:
              There are compounds completely or partially not classified by
              NPClassifier due to missing SMILES and/or NPClassifier not
              producing full classifications for all compounds.
              If possible, consider adding classifications manually for these
              before running compDis() for optimal results.
              See ?compDis for details.")
    }

    # Replace all superclass and class NA with pseudo-variables.
    # Note that we're not replacing things for compounds with missing pathways.
    # These compounds with missing SMILES or with SMILES but without pathway
    # are treated equally and below given 1 or mean dissim to other comps)
    for (i in 1:nrow(npcTable)) {
      if (is.na(npcTable$superclass[i]) && !is.na(npcTable$pathway[i])) {
        npcTable$superclass[i] <- paste("superclass", npcTable$compound[i], sep = "_")
      }
      if (is.na(npcTable$class[i]) && !is.na(npcTable$pathway[i])) {
        npcTable$class[i] <- paste("class", npcTable$compound[i], sep = "_")
      }
    }

    # From long to W ###
    npcTableW <- data.frame(compound = npcTable$compound)

    for (i in 1:nrow(npcTable)) { # For each compound
      for (j in which(colnames(npcTable) == "pathway"):ncol(npcTable)) {
        # For each classification (from pathway and onwards)

        if (npcTable[i, j] %in% colnames(npcTableW)) {
          # If the name already exist as column in npcTableW

          # Get column number and then add 1 in correct column
          colNumber <- match(npcTable[i, j], colnames(npcTableW))
          npcTableW[i, colNumber] <- 1

        } else if (!is.na(npcTable[i,j])) {
          # If the name do not already exist as column in npcTableW
          # (if i,j is NA nothing is done)

          # Make new column, with name from npcTable[i,j]. Add 1 to correct row
          npcTableW[,npcTable[i,j]] <- NA
          npcTableW[i,npcTable[i,j]] <- 1
        }
      }
    }

    # Fixing Greek letters in class names. Included all.
    # gsub() can only handle one replacement at a time

    # Lower case
    correctColNames <- gsub("\u03b1", "alpha", colnames(npcTableW))
    correctColNames <- gsub("\u03b2", "beta", correctColNames)
    correctColNames <- gsub("\u03b3", "gamma", correctColNames)
    correctColNames <- gsub("\u03b4", "delta", correctColNames)
    correctColNames <- gsub("\u03b5", "epsilon", correctColNames)
    correctColNames <- gsub("\u03b6", "zeta", correctColNames)
    correctColNames <- gsub("\u03b7", "eta", correctColNames)
    correctColNames <- gsub("\u03b8", "theta", correctColNames)
    correctColNames <- gsub("\u03b9", "iota", correctColNames)
    correctColNames <- gsub("\u03ba", "kappa", correctColNames)
    correctColNames <- gsub("\u03bb", "lambda", correctColNames)
    correctColNames <- gsub("\u03bc", "mu", correctColNames)
    correctColNames <- gsub("\u03bd", "nu", correctColNames)
    correctColNames <- gsub("\u03be", "xi", correctColNames)
    correctColNames <- gsub("\u03bf", "omicron", correctColNames)
    correctColNames <- gsub("\u03c0", "pi", correctColNames)
    correctColNames <- gsub("\u03c1", "rho", correctColNames)
    correctColNames <- gsub("\u03c3", "sigma", correctColNames)
    correctColNames <- gsub("\u03c4", "tau", correctColNames)
    correctColNames <- gsub("\u03c5", "upsilon", correctColNames)
    correctColNames <- gsub("\u03c6", "phi", correctColNames)
    correctColNames <- gsub("\u03c7", "chi", correctColNames)
    correctColNames <- gsub("\u03c8", "psi", correctColNames)
    correctColNames <- gsub("\u03c9", "omega", correctColNames)

    # Upper case
    correctColNames <- gsub("\u0391", "Alpha", colnames(npcTableW))
    correctColNames <- gsub("\u0392", "Beta", correctColNames)
    correctColNames <- gsub("\u0393", "Gamma", correctColNames)
    correctColNames <- gsub("\u0394", "Delta", correctColNames)
    correctColNames <- gsub("\u0395", "Epsilon", correctColNames)
    correctColNames <- gsub("\u0396", "Zeta", correctColNames)
    correctColNames <- gsub("\u0397", "Eta", correctColNames)
    correctColNames <- gsub("\u0398", "Theta", correctColNames)
    correctColNames <- gsub("\u0399", "Iota", correctColNames)
    correctColNames <- gsub("\u039a", "Kappa", correctColNames)
    correctColNames <- gsub("\u039b", "Lambda", correctColNames)
    correctColNames <- gsub("\u039c", "Mu", correctColNames)
    correctColNames <- gsub("\u039d", "Nu", correctColNames)
    correctColNames <- gsub("\u039e", "Xi", correctColNames)
    correctColNames <- gsub("\u039f", "Omicron", correctColNames)
    correctColNames <- gsub("\u03a0", "Pi", correctColNames)
    correctColNames <- gsub("\u03a1", "Rho", correctColNames)
    correctColNames <- gsub("\u03a3", "Sigma", correctColNames)
    correctColNames <- gsub("\u03a4", "Tau", correctColNames)
    correctColNames <- gsub("\u03a5", "Upsilon", correctColNames)
    correctColNames <- gsub("\u03a6", "Phi", correctColNames)
    correctColNames <- gsub("\u03a7", "Chi", correctColNames)
    correctColNames <- gsub("\u03a8", "Psi", correctColNames)
    correctColNames <- gsub("\u03a9", "Omega", correctColNames)

    colnames(npcTableW) <- correctColNames

    # Replacing NA with 0
    npcTableW[is.na(npcTableW)] <- 0

    # Making distance matrix out of it
    npcDisMat <- as.matrix(vegan::vegdist(npcTableW[, 2:ncol(npcTableW)],
                                          method = "jaccard"))

    colnames(npcDisMat) <- npcTableW$compound
    rownames(npcDisMat) <- npcTableW$compound

    # If there are >1 NA (unknown compound) these become NaN to each
    # other in vegdist. Setting these manually to 1. (This does not affect
    # any mean dissimilarity calculations, as those are done for only
    # known compounds)
    npcDisMat[is.nan(npcDisMat)] <- 1

    # If one decides to set unknown compounds to mean values.
    # Done for both known-unknown and unknown-unknown pairs
    if (unknownCompoundsMean && any(is.na(npcTable$pathway))) {

      # Subsetting only known compounds
      npcKnown <- npcDisMat[-which(is.na(npcTable$pathway)),
                            -which(is.na(npcTable$pathway))]

      # mean compound dissimilarity of known compounds
      meanDis <- mean(npcKnown[lower.tri(npcKnown)], na.rm = TRUE)

      # We replace those rows and columns (can't do both at once) with mean values
      npcDisMat[which(is.na(npcTable$pathway)),] <- meanDis
      npcDisMat[,which(is.na(npcTable$pathway))] <- meanDis

      # And the make sure diagonal is all 0 again
      diag(npcDisMat) <- 0

    }
    compoundDisMatList[["npcDisMatMat"]] <- npcDisMat
  }

  if ("PubChemFingerprint" %in% type) { # Dissimilarities from Fingerprints

    message("Calculating compound dissimilarity matrix using Fingerprints...")

    if(any(is.na(compoundData$inchikey))){
      message("Fingerprint calculations: There are compounds with missing inchikey")
    }

    # Getting CID from inchikey
    compoundCID <- webchem::get_cid(query = compoundData$inchikey,
                                    from = "inchikey",
                                    match = "first")

    # If there are NA cid (due to NA inchikey) pubchemCidToSDF can't handle NAs
    if(any(is.na(compoundCID$cid))) { # if at least 1 NA

      # Get all not NA cid and their fingerprints
      cidNoNA <- compoundCID$cid[!is.na(compoundCID$cid)]
      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(cidNoNA))
      compoundbit <- ChemmineR::fp2bit(compoundSDF)
      compoundFinger <- as.data.frame(compoundbit@fpma)
      colnames(compoundFinger) <- c(paste0("bit", seq(1:881)))

      # Make a similar dataframe with only 0, with same number
      # of columns and number of rows equal to number of NA compounds.
      # We put 0 and not NA into this, because we use this to calculate
      # dissimilarities. Rows with all 0 values will have a jaccard
      # distance of 1 to all others (as I currently want). In contrast,
      # vegdist() throws error if there are NAs in community matrix
      # (and we don't want that). This is correct and the same as in npcDis.
      unknownFinger <- as.data.frame(matrix(data = 0,
                                            nrow = sum(is.na(compoundCID$cid)),
                                            ncol = ncol(compoundFinger)))
      colnames(unknownFinger) <- c(paste0("bit", seq(1:881)))

      # Get index of NA cid
      unknownRow <- which(is.na(compoundCID$cid))

      # This puts each NA row into it's correct place using rbind(),
      # by taking first part of compoundFinger, inserting NA row into
      # correct place, and then taking second part of compoundFinger.
      # rbind() is apperently slow, but should work here.
      # https://stackoverflow.com/questions/11561856/add-new-row-to-dataframe-at-specific-row-index-not-appended
      # This could alternatively be done with dplyr add_row() with .before =
      for (i in 1:length(unknownRow)) {
        if(unknownRow[i] == 1) { # If first is NA
          compoundFinger <- rbind(unknownFinger[i,], compoundFinger)
        } else if (unknownRow[i] > nrow(compoundFinger)) { # If last(s) are NA
          compoundFinger <- rbind(compoundFinger, unknownFinger[i,])
        } else {
          compoundFinger <- rbind(compoundFinger[1:(unknownRow[i]-1),],
                                  unknownFinger[i,],
                                  compoundFinger[unknownRow[i]:
                                                   nrow(compoundFinger),])
        }
      }
    } else { # If no NA
      # Get all cid and their fingerprints
      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid))
      compoundbit <- ChemmineR::fp2bit(compoundSDF)
      compoundFinger <- as.data.frame(compoundbit@fpma)
      colnames(compoundFinger) <- c(paste0("bit", seq(1:881)))
    }

    # Calculate dissimilarity matrix based on fingerprints
    fingerDis <- vegan::vegdist(compoundFinger, method = "jaccard")
    fingerDisMat <- as.matrix(fingerDis)
    colnames(fingerDisMat) <- compoundData$compound
    rownames(fingerDisMat) <- compoundData$compound

    # If there are >1 NA (unknown compound) these become NaN to each
    # other in vegdist. Setting these manually to 1.
    fingerDisMat[is.nan(fingerDisMat)] <- 1

    # If there are unknown compound and one decides to set
    # unknown compounds to mean values
    if (unknownCompoundsMean & any(is.na(compoundCID$cid))) {

      # Subsetting only known compounds
      fingerKnown <- fingerDisMat[-unknownRow, -unknownRow]

      # mean compound dissimilarity
      meanDis <- mean(fingerKnown[lower.tri(fingerKnown)])

      # We replace those rows and columns (can't do both at once) with mean values
      fingerDisMat[unknownRow,] <- meanDis
      fingerDisMat[,unknownRow] <- meanDis

      # And the make sure diagonal is all 0 again
      diag(fingerDisMat) <- 0

    }

    compoundDisMatList[["fingerDisMat"]] <- fingerDisMat

  }

  if ("fMCS" %in% type) { # Dissimilarities from fMCS

    message("Calculating compound dissimilarity matrix using fMCS...")

    if(any(is.na(compoundData$inchikey))){
      message("fMCS calculations: There are compounds with missing inchikey")
    }

    if(!exists("compoundCID")) {
      compoundCID <- webchem::get_cid(query = compoundData$inchikey,
                                      from = "inchikey",
                                      match = "first")
    }

    if (any(is.na(compoundCID$cid))) { # If there are NAs

      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid[!is.na(compoundCID$cid)]))

      unknownRow <- which(is.na(compoundCID$cid))

      # Doing with 1 atom and 1 bond mismatch for now. I think there is a motivation
      # for this in some earlier R-script. Note that this is similarity matrix
      # as it's Tanimoto coefficient (Jaccard similarity)
      fmcsSimMat <- sapply(ChemmineR::cid(compoundSDF),
                           function(x) fmcsR::fmcsBatch(compoundSDF[x],
                                                 compoundSDF,
                                                 au = 1,
                                                 bu = 1)[,"Tanimoto_Coefficient"])

      meanSim <- mean(fmcsSimMat[lower.tri(fmcsSimMat)])

      # Putting rows/column with unknown compounds into correct place
      # Note that rbind() adds whole row even if only single value is added
      if (unknownCompoundsMean) { # Adding mean similarity

        for (i in 1:length(unknownRow)) {

          if(unknownRow[i] == 1) { # If first compound is NA
            fmcsSimMat <- rbind(meanSim, fmcsSimMat)
            fmcsSimMat <- cbind(meanSim, fmcsSimMat)
          } else if (unknownRow[i] > nrow(fmcsSimMat)) { # If last compound(s) are NA
            fmcsSimMat <- rbind(fmcsSimMat, meanSim)
            fmcsSimMat <- cbind(fmcsSimMat, meanSim)
          } else {
            fmcsSimMat <- rbind(fmcsSimMat[1:(unknownRow[i]-1),],
                                meanSim,
                                fmcsSimMat[unknownRow[i]:nrow(fmcsSimMat),])
            fmcsSimMat <- cbind(fmcsSimMat[,1:(unknownRow[i]-1)],
                                meanSim,
                                fmcsSimMat[,unknownRow[i]:ncol(fmcsSimMat)])
          }
        }
      } else { # Adding 0 similarity

        for (i in 1:length(unknownRow)) {

          if(unknownRow[i] == 1) { # If first compound is NA
            fmcsSimMat <- rbind(0, fmcsSimMat)
            fmcsSimMat <- cbind(0, fmcsSimMat)
          } else if (unknownRow[i] > nrow(fmcsSimMat)) { # If last compound(s) are NA
            fmcsSimMat <- rbind(fmcsSimMat, 0)
            fmcsSimMat <- cbind(fmcsSimMat, 0)
          } else {
            fmcsSimMat <- rbind(fmcsSimMat[1:(unknownRow[i]-1),],
                                0,
                                fmcsSimMat[unknownRow[i]:nrow(fmcsSimMat),])
            fmcsSimMat <- cbind(fmcsSimMat[,1:(unknownRow[i]-1)],
                                0,
                                fmcsSimMat[,unknownRow[i]:ncol(fmcsSimMat)])
          }
        }
      }

      diag(fmcsSimMat) <- 1

    } else {

      compoundSDF <- ChemmineR::pubchemCidToSDF(as.numeric(compoundCID$cid))

      fmcsSimMat <- sapply(ChemmineR::cid(compoundSDF),
                           function(x) fmcsR::fmcsBatch(compoundSDF[x],
                                                 compoundSDF,
                                                 au = 1,
                                                 bu = 1)[,"Tanimoto_Coefficient"])
    }

    fmcsDisMat <- 1 - fmcsSimMat
    colnames(fmcsDisMat) <- compoundData$compound
    rownames(fmcsDisMat) <- compoundData$compound

    compoundDisMatList[["fmcsDisMat"]] <- fmcsDisMat
  }

  if (length(type) > 1) { # Matrix with mean if >1 type was calculated

    compoundDisMatList[["meanDisMat"]] <- Reduce("+", compoundDisMatList) /
      length(compoundDisMatList)

  }
  message("Done")
  on.exit(closeAllConnections()) # Makes connection warning print directly,
  # rather than randomly afterwards
  return(compoundDisMatList)
}


